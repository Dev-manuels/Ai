import pandas as pd
import numpy as np
from typing import Dict, List, Optional

class TacticalEngine:
    """
    Calculates proprietary tactical and momentum features from event-level and team-level data.
    """
    def __init__(self):
        # xT (Expected Threat) grid - simplified 12x8 grid
        self.xt_grid = np.zeros((8, 12))
        self._initialize_xt_grid()

    def _initialize_xt_grid(self):
        # Simplified xT values - higher closer to the opponent's goal (right side)
        for x in range(12):
            for y in range(8):
                self.xt_grid[y, x] = (x / 11.0) ** 2 * (1 - abs(y - 3.5) / 4.0)

    def calculate_xt(self, events_df: pd.DataFrame) -> pd.DataFrame:
        """
        Calculates total xT generated by each team in each match.
        events_df should have columns: [fixture_id, team_id, start_x, start_y, end_x, end_y, type]
        Returns a DataFrame indexed by fixture_id with columns [home_xt, away_xt] if match context provided,
        otherwise just total per team.
        """
        if events_df.empty:
            return pd.DataFrame()

        # Mapping coordinates to grid indices (assuming 0-100 or 0-1 range)
        events_df = events_df.copy()
        events_df['start_grid_x'] = (events_df['start_x'] * 11).astype(int).clip(0, 11)
        events_df['start_grid_y'] = (events_df['start_y'] * 7).astype(int).clip(0, 7)
        events_df['end_grid_x'] = (events_df['end_x'] * 11).astype(int).clip(0, 11)
        events_df['end_grid_y'] = (events_df['end_y'] * 7).astype(int).clip(0, 7)

        xt_start = self.xt_grid[events_df['start_grid_y'], events_df['start_grid_x']]
        xt_end = self.xt_grid[events_df['end_grid_y'], events_df['end_grid_x']]

        events_df['xt_added'] = np.maximum(0, xt_end - xt_start)

        return events_df.groupby(['fixture_id', 'team_id'])['xt_added'].sum().unstack(fill_value=0)

    def calculate_field_tilt(self, touches_df: pd.DataFrame, home_team_ids: Dict[str, str]) -> pd.Series:
        """
        Field Tilt: Share of final third touches.
        touches_df should have columns: [fixture_id, team_id, x] (where x is 0-1)
        home_team_ids: Mapping of fixture_id to home_team_id
        Returns a Series of home field tilt indexed by fixture_id.
        """
        if touches_df.empty:
            return pd.Series()

        final_third = touches_df[touches_df['x'] > 0.66]

        results = {}
        for fixture_id in touches_df['fixture_id'].unique():
            fixture_touches = final_third[final_third['fixture_id'] == fixture_id]
            if fixture_touches.empty:
                results[fixture_id] = 0.5
                continue

            home_id = home_team_ids.get(fixture_id)
            home_touches = len(fixture_touches[fixture_touches['team_id'] == home_id])
            total_touches = len(fixture_touches)
            results[fixture_id] = home_touches / total_touches if total_touches > 0 else 0.5

        return pd.Series(results)

    def calculate_pressure_metrics(self, events_df: pd.DataFrame) -> pd.DataFrame:
        """
        Calculates PPDA (Passes Per Defensive Action) or similar pressure indicators for each fixture.
        """
        if events_df.empty:
            return pd.DataFrame()

        # Simplified PPDA: return placeholder per fixture for now
        results = []
        for fixture_id in events_df['fixture_id'].unique():
            results.append({
                'fixture_id': fixture_id,
                'ppda_home': 10.0,
                'ppda_away': 10.0
            })

        return pd.DataFrame(results).set_index('fixture_id')

    def get_composite_momentum(self, window_events: pd.DataFrame) -> float:
        """
        Combines xT, field tilt, and shot volume into a single momentum score (-1.0 to 1.0).
        """
        # Logic to combine multiple signals into a proprietary momentum indicator
        return 0.0

class RefereeEngine:
    """
    Hybrid model for referee and officiating tendencies.
    """
    def __init__(self):
        self.referee_stats = {} # Mock storage for historical averages

    def get_referee_profile(self, referee_id: str, league_id: str) -> Dict[str, float]:
        """
        Returns a hybrid profile: static baseline + league-specific context.
        """
        baseline = self.referee_stats.get(referee_id, {"avg_cards": 3.5, "foul_strictness": 0.5})

        # Dynamic adjustment based on league context (e.g., Premier League vs La Liga)
        league_adj = 1.2 if league_id == "la_liga" else 1.0

        return {
            "predicted_cards": baseline["avg_cards"] * league_adj,
            "strictness_score": baseline["foul_strictness"]
        }
